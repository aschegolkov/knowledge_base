 
 
**Именно идея сохранения в маршрутной таблице только реально используемых виртуальных путей и легла в основу разработки протокола MPLS и сопряженных с ним протоколов маршрутизации.**

Протокол MPLS хорошо приспособлен для формирования виртуальных сетей (VPN) повышенного быстродействия (**метки коммутируются быстрее, чем маршрутизируются пакеты**). Принципиальной основой MPLS являются IP-туннели. Для его работы нужна поддержка протокола маршрутизации MP-BGP (RFC-2858). Протокол MPLS может работать практически для любого маршрутизируемого транспортного протокола (не только IP). При появлении пакета в виртуальной сети ему присваивается метка, которая не позволяет ему покинуть пределы данной виртуальной сети. Протокол MPLS предоставляет возможность обеспечения значения **QoS**, гарантирующего более высокую безопасность.  Для одного и того же набора узлов можно сформировать несколько разных виртуальных сетей (используя разные метки), **например, для разных видов QoS**. 

Cтек меток размещается между заголовками сетевого и канального уровней (L2 и L3)

![mpls label](http://book.itep.ru/4/4/mpls/label.jpg)

**Label** — собственно сама метка. Длина — 20 бит.
**TC (**CoS**)**  — Traffic Class. Несёт в себе приоритет пакета, как поле DSCP в IP.
Длина 3 бита. То есть может кодировать 8 различных значений.
*Например, при передаче IP-пакета через сеть MPLS значению в поле DSCP определённым образом ставится в соответствие значение TC. Таким образом пакет может почти одинаково обрабатываться в очередях на всём протяжении своего пути, как на участке чистого IP, так и в MPLS.*
*Но, естественно, это преобразование с потерями — шести битам DSCP тесно в 3 битах TC: 64 против 8. ***Поэтому существует специальная таблица соответствий, где целый диапазон — это всего лишь одно значение***.*


**S — Bottom of Stack** — индикатор дна стека меток длиной в 1 бит. Заголовков MPLS на пакете может быть несколько, например, внешняя для коммутации в сети MPLS, а внутренняя указывает на определённый VPN. Чтобы LSR понимал с чем он имеет дело. В бит S записывается «1», если это последняя метка (достигнуто дно стека) и «0», если стек содержит больше одной метки (ещё не дно). То есть LSR не знает, сколько всего меток в стеке, но знает, одна она или больше — да этого и достаточно на самом-то деле. Ведь любые решения принимаются на основе только самой верхней метки, независимо от того, что там под ней. Зато, снимая метку, он уже знает, что дальше сделать с пакетом: продолжить работу с процессом MPLS или отдать его какому-то другому (IP, Ethernet, ATM, FR итд).

![mpls lables](/docs/img/mpls_lables.png)


 Пример LDP LSP: 

```bash
                 LSP Information: LDP LSP
----------------------------------------------
FEC                In/Out Label    In/Out IF  
1.1.1.1/32   NULL/54846      -/Eth-Trunk2.2    # Метка in трафика  после per-hop behaviour (PHB)  UPLINK 1 
1.1.1.1/32   51122/54846     -/Eth-Trunk2.2    # Метка out трафика UPLINK 1            
1.1.1.1/32   NULL/6415       -/Eth-Trunk1.2    # Метка in трафика   после per-hop behaviour (PHB) UPLINK 2
1.1.1.1/32   51122/6415      -/Eth-Trunk1.2  # Метка out трафика UPLINK 2 
```